---
title: Real-World CLI
description: Complete production-ready CLI with type generation and advanced patterns
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Steps } from 'fumadocs-ui/components/steps';

# Real-World CLI Example

A complete, production-ready CLI application demonstrating best practices, type generation, CLI wrappers, documentation generation, and command analytics.

<Callout type="info">
  This example showcases a developer productivity CLI with 12+ commands, demonstrating real-world patterns including CLI wrappers, documentation generation, command analytics, and type-safe execution.
</Callout>

## Overview

This example shows a developer productivity CLI with:
- **12+ Production Commands** - Complete command suite for developer productivity
- **Type Generation** - Full TypeScript definitions for all commands
- **CLI Wrappers** - Type-safe command execution and discovery
- **Documentation Generation** - Auto-generate docs from command metadata
- **Command Analytics** - Track usage and performance
- **Git Integration** - Branch management, PR tools, sync utilities
- **Docker Support** - Container management and statistics
- **Project Management** - Build, dev, test, and new project commands
- **Environment Management** - Environment variable handling
- **Cleanup Utilities** - System and Docker cleanup tools

## Project Structure

```
real-world/
├── cli.ts                    # CLI entry point
├── .bunli/
│   └── commands.gen.ts      # Generated types (auto-created)
├── bunli.config.ts          # Configuration with codegen
├── commands/
│   ├── index.ts             # Command manifest
│   ├── clean.ts             # System cleanup
│   ├── env.ts               # Environment management
│   ├── update.ts            # Update utilities
│   ├── docker/              # Docker commands
│   │   ├── clean.ts
│   │   └── stats.ts
│   ├── git/                 # Git utilities
│   │   ├── branch.ts
│   │   ├── pr.ts
│   │   └── sync.ts
│   └── project/             # Project management
│       ├── build.ts
│       ├── dev.ts
│       ├── new.ts
│       └── test.ts
├── package.json
└── README.md
```

## Generated Types Showcase

The type generation creates comprehensive TypeScript definitions for all commands:

```typescript
// Generated in .bunli/commands.gen.ts
import { getCommandApi, listCommands, hasCommand } from './commands.gen'

// Command discovery
const commands = listCommands()
console.log(commands.length) // 12+ commands

// Type-safe command access
const gitApi = getCommandApi('git')
const branchApi = getCommandApi('git.branch')
const dockerApi = getCommandApi('docker')

// Check command existence
if (hasCommand('project.build')) {
  const buildApi = getCommandApi('project.build')
  console.log(buildApi.options) // { target: {...}, watch: {...} }
}
```

## Type-Safe Command Execution

Create type-safe wrappers around your CLI:

```typescript
// cli-wrapper.ts
import { getCommandApi, listCommands } from './commands.gen'

class DevToolsCLI {
  async executeCommand(commandName: string, options: Record<string, any>) {
    const command = getCommandApi(commandName as any)
    
    // Type-safe option validation
    for (const [key, value] of Object.entries(options)) {
      const option = command.options[key]
      if (!option) {
        throw new Error(`Unknown option: ${key}`)
      }
      
      // Validate type based on schema
      if (option.type === 'string' && typeof value !== 'string') {
        throw new Error(`Option ${key} must be a string`)
      }
    }
    
    // Execute command with validated options
    console.log(`Executing ${commandName} with options:`, options)
  }
  
  getAvailableCommands() {
    return listCommands().map(cmd => ({
      name: cmd.name,
      description: cmd.description,
      options: Object.keys(getCommandApi(cmd.name).options)
    }))
  }
}
```

## Documentation Generation

Generate documentation from command metadata:

```typescript
// docs-generator.ts
import { listCommands, getCommandApi } from './commands.gen'

function generateMarkdownDocs() {
  const commands = listCommands()
  
  let docs = '# DevTools CLI Documentation\n\n'
  
  for (const cmd of commands) {
    const api = getCommandApi(cmd.name)
    
    docs += `## ${cmd.name}\n\n`
    docs += `${cmd.description}\n\n`
    
    if (Object.keys(api.options).length > 0) {
      docs += '### Options\n\n'
      for (const [name, option] of Object.entries(api.options)) {
        docs += `- \`--${name}\` (${option.type})`
        if (option.required) docs += ' **Required**'
        if (option.default !== undefined) docs += ` - Default: ${option.default}`
        docs += `\n  ${option.description}\n`
      }
      docs += '\n'
    }
  }
  
  return docs
}

// Generate docs
const markdown = generateMarkdownDocs()
console.log(markdown)
```

## Command Analytics

Track command usage with type safety:

```typescript
// analytics.ts
import { getCommandNames, getCommandApi } from './commands.gen'

class CommandAnalytics {
  private usage: Map<string, number> = new Map()
  private options: Map<string, Map<string, number>> = new Map()
  
  trackCommand(commandName: string, options: Record<string, any>) {
    // Validate command exists
    if (!getCommandNames().includes(commandName as any)) {
      throw new Error(`Unknown command: ${commandName}`)
    }
    
    // Track usage
    const current = this.usage.get(commandName) || 0
    this.usage.set(commandName, current + 1)
    
    // Track option usage
    const command = getCommandApi(commandName as any)
    for (const optionName of Object.keys(options)) {
      if (command.options[optionName]) {
        const optionUsage = this.options.get(commandName) || new Map()
        const optionCount = optionUsage.get(optionName) || 0
        optionUsage.set(optionName, optionCount + 1)
        this.options.set(commandName, optionUsage)
      }
    }
  }
  
  getUsageStats() {
    return Array.from(this.usage.entries()).map(([cmd, count]) => ({
      command: cmd,
      count,
      description: getCommandApi(cmd as any).description,
      options: Object.keys(getCommandApi(cmd as any).options)
    }))
  }
}
```

## Configuration

The example includes comprehensive configuration with code generation:

```typescript
// bunli.config.ts
export default defineConfig({
  name: 'devtools',
  version: '2.1.0',
  description: 'Developer productivity tools',
  
  
  commands: {
    manifest: './commands/index.ts'
  },
  
  build: {
    entry: './cli.ts',
    outdir: './dist',
    targets: ['darwin-arm64', 'darwin-x64', 'linux-x64'],
    compress: true
  }
})
```

## Usage Examples

<Tabs groupId="usage" defaultValue="development">
  <Tab value="development" label="Development Mode">
    ```bash
    # Start development with hot reload and type generation
    bun run dev
    
    # Run specific commands
    bun run dev git branch --list
    bun run dev docker stats --format table
    bun run dev project build --target production
    ```
  </Tab>
  
  <Tab value="production" label="Production Build">
    ```bash
    # Build for all platforms
    bun run build
    
    # Run built executable
    ./dist/devtools --help
    ./dist/devtools git branch --current
    ./dist/devtools project new --name my-app --template react
    ```
  </Tab>
  
  <Tab value="generation" label="Type Generation">
    ```bash
    # Generate types manually
    bunli generate
    
    # Watch for changes
    bunli generate --watch
    
    # Custom output location
    bunli generate
    ```
  </Tab>
</Tabs>

## Commands Overview

### Git Commands
- `git branch` - Branch management and listing
- `git pr` - Pull request utilities
- `git sync` - Synchronize branches

### Docker Commands
- `docker clean` - Clean up Docker resources
- `docker stats` - Container statistics

### Project Commands
- `project build` - Build projects
- `project dev` - Development server
- `project new` - Create new projects
- `project test` - Run tests

### System Commands
- `clean` - System cleanup
- `env` - Environment management
- `update` - Update utilities

## Testing with Generated Types

The example includes tests that use generated types:

```typescript
// test/cli.test.ts
import { test, expect } from 'bun:test'
import { getCommandApi, listCommands } from '../commands.gen'

test('generated types are valid', () => {
  const commands = listCommands()
  expect(commands.length).toBeGreaterThan(10)
  
  // Test specific command
  const gitApi = getCommandApi('git')
  expect(gitApi.description).toBe('Git utilities')
  
  // Test nested command
  const branchApi = getCommandApi('git.branch')
  expect(branchApi.options).toHaveProperty('list')
})

test('command discovery works', () => {
  const commands = listCommands()
  const commandNames = commands.map(c => c.name)
  
  expect(commandNames).toContain('git')
  expect(commandNames).toContain('docker')
  expect(commandNames).toContain('project')
})
```

## Key Features Demonstrated

1. **Production Configuration** - Complete bunli.config.ts setup
2. **Type Generation** - Full TypeScript definitions for all commands
3. **CLI Wrappers** - Type-safe command execution patterns
4. **Documentation Generation** - Auto-generate docs from metadata
5. **Command Analytics** - Usage tracking and statistics
6. **Error Handling** - Comprehensive error handling throughout
7. **Testing** - Tests using generated types
8. **Build System** - Multi-platform builds with compression
9. **Command Organization** - Nested commands and manifests
10. **Real-World Patterns** - Production-ready code patterns

## Best Practices Shown

- **Modular Architecture** - Separated concerns and clean organization
- **Type Safety** - Full TypeScript coverage with generated types
- **Error Handling** - Graceful failures and helpful error messages
- **Configuration Management** - Centralized configuration with validation
- **Testing** - Comprehensive test coverage using generated types
- **Documentation** - Clear command descriptions and help text
- **User Experience** - Interactive prompts and progress indicators
- **Performance** - Efficient command loading and execution
- **Extensibility** - Easy to add new commands and features
- **Maintainability** - Clean, readable, and well-documented code

## Next Steps

<Steps>

### 1. Explore Type Generation
Learn more about generating TypeScript definitions from your commands:
- [Type Generation Guide](/docs/guides/type-generation) - Complete guide to code generation

### 2. Study Command Organization
Understand how to structure complex CLIs:
- [Command Structure](/docs/examples/command-structure) - Organize commands

### 3. Build Interactive CLIs
Create engaging user experiences:
- [Interactive Prompts](/docs/examples/interactive) - Build interactive CLIs

### 4. Add Validation
Ensure robust input handling:
- [Schema Validation](/docs/examples/schema-validation) - Add validation

### 5. Development Workflow
Master the Bunli development process:
- [bunli CLI](/docs/packages/cli) - Development workflow

</Steps>

<Callout type="tip">
  This example demonstrates the full power of Bunli's type generation system. Use it as a reference for building production-ready CLIs with advanced patterns like CLI wrappers, documentation generation, and command analytics.
</Callout>