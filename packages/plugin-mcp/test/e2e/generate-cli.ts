/**
 * Generate a runnable CLI from MCP tools
 *
 * This creates a standalone TypeScript file that can be executed directly.
 */

import type { MCPTool } from '../../src/types.js'
import { toCommandName, toFlagName, toPascalCase, escapeString } from '../../src/utils.js'

export interface GenerateCliOptions {
  /** Namespace for commands (e.g., 'exa') */
  namespace: string
  /** CLI name */
  cliName: string
  /** Description for the CLI */
  description?: string
  /** How to invoke the MCP server (for the handler) */
  serverInvocation: {
    type: 'stdio'
    command: string
    args?: string[]
    envVar?: string // e.g., 'EXA_API_KEY'
  } | {
    type: 'http'
    url: string
    apiKeyEnvVar?: string
  }
}

/**
 * Generate a complete, runnable CLI TypeScript file
 */
export function generateCli(tools: MCPTool[], options: GenerateCliOptions): string {
  const { namespace, cliName, description, serverInvocation } = options

  const lines: string[] = []

  // Header
  lines.push(`#!/usr/bin/env bun`)
  lines.push(`/**`)
  lines.push(` * ${description || `${cliName} - Generated CLI from MCP tools`}`)
  lines.push(` *`)
  lines.push(` * Auto-generated by @bunli/plugin-mcp`)
  lines.push(` * Do not edit manually - regenerate with: bun test test/e2e/exa-mcp.test.ts --update`)
  lines.push(` */`)
  lines.push(``)

  // Imports
  lines.push(`import { createCLI, defineCommand, option } from '@bunli/core'`)
  lines.push(`import { Client } from '@modelcontextprotocol/sdk/client/index.js'`)

  if (serverInvocation.type === 'stdio') {
    lines.push(`import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'`)
  } else {
    lines.push(`import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js'`)
  }

  lines.push(`import { z } from 'zod'`)
  lines.push(``)

  // Environment check
  if (serverInvocation.type === 'stdio' && serverInvocation.envVar) {
    lines.push(`// Check for required environment variable`)
    lines.push(`const ${serverInvocation.envVar} = process.env.${serverInvocation.envVar}`)
    lines.push(`if (!${serverInvocation.envVar}) {`)
    lines.push(`  console.error('Error: ${serverInvocation.envVar} environment variable is required')`)
    lines.push(`  process.exit(1)`)
    lines.push(`}`)
    lines.push(``)
  } else if (serverInvocation.type === 'http' && serverInvocation.apiKeyEnvVar) {
    lines.push(`// Check for required environment variable`)
    lines.push(`const ${serverInvocation.apiKeyEnvVar} = process.env.${serverInvocation.apiKeyEnvVar}`)
    lines.push(`if (!${serverInvocation.apiKeyEnvVar}) {`)
    lines.push(`  console.error('Error: ${serverInvocation.apiKeyEnvVar} environment variable is required')`)
    lines.push(`  process.exit(1)`)
    lines.push(`}`)
    lines.push(``)
  }

  // MCP client helper
  lines.push(`// MCP client helper`)
  lines.push(`async function callTool(toolName: string, args: Record<string, unknown>) {`)

  if (serverInvocation.type === 'stdio') {
    lines.push(`  const transport = new StdioClientTransport({`)
    lines.push(`    command: '${serverInvocation.command}',`)
    if (serverInvocation.args) {
      lines.push(`    args: ${JSON.stringify(serverInvocation.args)},`)
    }
    if (serverInvocation.envVar) {
      lines.push(`    env: { ...process.env, ${serverInvocation.envVar}: ${serverInvocation.envVar}! }`)
    }
    lines.push(`  })`)
  } else {
    const urlWithKey = serverInvocation.apiKeyEnvVar
      ? `\`${serverInvocation.url}?x-api-key=\${${serverInvocation.apiKeyEnvVar}}\``
      : `'${serverInvocation.url}'`
    lines.push(`  const transport = new StreamableHTTPClientTransport(new URL(${urlWithKey}))`)
  }

  lines.push(``)
  lines.push(`  const client = new Client(`)
  lines.push(`    { name: '${cliName}', version: '1.0.0' },`)
  lines.push(`    { capabilities: {} }`)
  lines.push(`  )`)
  lines.push(``)
  lines.push(`  await client.connect(transport)`)
  lines.push(``)
  lines.push(`  try {`)
  lines.push(`    const result = await client.callTool({ name: toolName, arguments: args })`)
  lines.push(`    return result`)
  lines.push(`  } finally {`)
  lines.push(`    await client.close()`)
  lines.push(`  }`)
  lines.push(`}`)
  lines.push(``)

  // Generate commands
  lines.push(`// Commands`)
  for (const tool of tools.sort((a, b) => a.name.localeCompare(b.name))) {
    lines.push(generateCommandDefinition(tool, namespace))
    lines.push(``)
  }

  // CLI setup
  lines.push(`// CLI setup`)
  lines.push(`const cli = await createCLI({`)
  lines.push(`  name: '${cliName}',`)
  lines.push(`  version: '0.0.0',`)
  lines.push(`  description: '${escapeString(description || `CLI for ${namespace} MCP tools`)}'`)
  lines.push(`})`)
  lines.push(``)

  // Register commands
  for (const tool of tools.sort((a, b) => a.name.localeCompare(b.name))) {
    const varName = `${toPascalCase(tool.name)}Command`
    lines.push(`cli.command(${varName})`)
  }
  lines.push(``)

  // Run
  lines.push(`// Run the CLI`)
  lines.push(`await cli.run()`)

  return lines.join('\n')
}

/**
 * Generate a single command definition
 */
function generateCommandDefinition(tool: MCPTool, namespace: string): string {
  const commandName = toCommandName(tool.name, namespace)
  const varName = `${toPascalCase(tool.name)}Command`

  const lines: string[] = []

  lines.push(`const ${varName} = defineCommand({`)
  lines.push(`  name: '${commandName}',`)
  lines.push(`  description: '${escapeString(tool.description || tool.name)}',`)

  // Options
  if (tool.inputSchema?.properties && Object.keys(tool.inputSchema.properties).length > 0) {
    lines.push(`  options: {`)

    const required = new Set(tool.inputSchema.required || [])
    const sortedProps = Object.entries(tool.inputSchema.properties).sort(([a], [b]) => a.localeCompare(b))

    for (const [propName, propSchema] of sortedProps) {
      const flagName = toFlagName(propName)
      const schema = propSchema as Record<string, unknown>
      const zodSchema = jsonSchemaToZodString(schema, required.has(propName))
      const desc = schema.description as string | undefined

      lines.push(`    '${flagName}': option(${zodSchema}, {`)
      if (desc) {
        lines.push(`      description: '${escapeString(desc)}'`)
      }
      lines.push(`    }),`)
    }

    lines.push(`  },`)
  }

  // Handler
  lines.push(`  async handler({ flags }) {`)
  lines.push(`    const result = await callTool('${tool.name}', flags as Record<string, unknown>)`)
  lines.push(`    console.log(JSON.stringify(result, null, 2))`)
  lines.push(`  }`)
  lines.push(`})`)

  return lines.join('\n')
}

/**
 * Convert JSON Schema to Zod schema string for codegen
 */
function jsonSchemaToZodString(schema: Record<string, unknown>, isRequired: boolean): string {
  let zodStr: string

  // Handle enum
  if (schema.enum && Array.isArray(schema.enum)) {
    const values = schema.enum
      .filter((v): v is string | number => typeof v === 'string' || typeof v === 'number')
      .map(v => typeof v === 'string' ? `'${escapeString(v)}'` : v)

    if (values.length > 0) {
      if (values.every(v => typeof v === 'string' || (typeof v === 'number' && !String(v).includes('.')))) {
        zodStr = `z.enum([${values.join(', ')}])`
      } else {
        zodStr = `z.union([${values.map(v => `z.literal(${v})`).join(', ')}])`
      }
    } else {
      zodStr = 'z.unknown()'
    }
  } else {
    // Handle type
    switch (schema.type) {
      case 'string':
        zodStr = 'z.string()'
        break
      case 'number':
        zodStr = 'z.coerce.number()'
        break
      case 'integer':
        zodStr = 'z.coerce.number().int()'
        break
      case 'boolean':
        zodStr = 'z.boolean()'
        break
      case 'array':
        zodStr = 'z.array(z.unknown())'
        break
      case 'object':
        zodStr = 'z.record(z.unknown())'
        break
      default:
        zodStr = 'z.unknown()'
    }
  }

  // Add constraints
  if (typeof schema.minimum === 'number') {
    zodStr += `.min(${schema.minimum})`
  }
  if (typeof schema.maximum === 'number') {
    zodStr += `.max(${schema.maximum})`
  }

  // Add default
  if (schema.default !== undefined) {
    const defaultVal = typeof schema.default === 'string'
      ? `'${escapeString(schema.default)}'`
      : JSON.stringify(schema.default)
    zodStr += `.default(${defaultVal})`
  }

  // Make optional if not required
  if (!isRequired && schema.default === undefined) {
    zodStr += '.optional()'
  }

  return zodStr
}
