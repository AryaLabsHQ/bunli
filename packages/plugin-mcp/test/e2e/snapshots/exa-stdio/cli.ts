#!/usr/bin/env bun
/**
 * Generated CLI for exa MCP server
 * Generated by @bunli/plugin-mcp E2E tests
 */
import { createCLI, defineCommand, option } from '@bunli/core'
import { z } from 'zod'

// ============================================================================
// Configuration
// ============================================================================

const DEFAULT_TIMEOUT = 60000

// ============================================================================
// Helpers (stubbed for snapshot testing)
// ============================================================================

async function callTool(toolName: string, args: Record<string, unknown>): Promise<unknown> {
  // Stub implementation - in real usage this would call the MCP server
  throw new Error(`callTool not implemented: ${toolName}`)
}

function printResult(result: unknown, format: string): void {
  switch (format) {
    case 'json':
      console.log(JSON.stringify(result, null, 2))
      return
    case 'raw':
      console.log(JSON.stringify(result, null, 2))
      return
    default:
      console.log(result)
  }
}

// ============================================================================
// Commands
// ============================================================================

const ExaWebSearchExaCommand = defineCommand({
  name: 'exa:web-search-exa',
  description: 'Search the web using Exa AI - performs real-time web searches and can scrape content from specific URLs. Supports configurable result counts and returns the content from the most relevant websites.',
  options: {
    'query': option(z.string(), { description: 'Websearch query' }),
    'num-results': option(z.coerce.number().optional(), { description: 'Number of search results to return (default: 8)' }),
    'livecrawl': option(z.enum(['fallback', 'preferred']).optional(), { description: 'Live crawl mode - \'fallback\': use live crawling as backup if cached content unavailable, \'preferred\': prioritize live crawling (default: \'fallback\')' }),
    'type': option(z.enum(['auto', 'fast', 'deep']).optional(), { description: 'Search type - \'auto\': balanced search (default), \'fast\': quick results, \'deep\': comprehensive search' }),
    'context-max-characters': option(z.coerce.number().optional(), { description: 'Maximum characters for context string optimized for LLMs (default: 10000)' }),
    'raw': option(z.string().optional(), { description: 'Raw JSON arguments' }),
    'timeout': option(z.coerce.number().optional(), { description: 'Timeout in ms', short: 't' }),
    'output': option(z.enum(['text', 'json', 'raw']).optional(), { description: 'Output format', short: 'o' }),
  },
  handler: async ({ flags }) => {
    const timeout = flags.timeout ?? DEFAULT_TIMEOUT
    const format = flags.output ?? 'text'
    let args: Record<string, unknown> = {}
    if (flags.raw) {
      args = JSON.parse(flags.raw)
    } else {
      if (flags['query'] !== undefined) args['query'] = flags['query']
      if (flags['num-results'] !== undefined) args['numResults'] = flags['num-results']
      if (flags['livecrawl'] !== undefined) args['livecrawl'] = flags['livecrawl']
      if (flags['type'] !== undefined) args['type'] = flags['type']
      if (flags['context-max-characters'] !== undefined) args['contextMaxCharacters'] = flags['context-max-characters']
    }
    try {
      const result = await callTool('web_search_exa', args)
      printResult(result, format)
    } catch (error) {
      console.error('Error:', error instanceof Error ? error.message : String(error))
      process.exit(1)
    }
  },
})

const ExaCompanyResearchExaCommand = defineCommand({
  name: 'exa:company-research-exa',
  description: 'Research companies using Exa AI - finds comprehensive information about businesses, organizations, and corporations. Provides insights into company operations, news, financial information, and industry analysis.',
  options: {
    'company-name': option(z.string(), { description: 'Name of the company to research' }),
    'num-results': option(z.coerce.number().optional(), { description: 'Number of search results to return (default: 5)' }),
    'raw': option(z.string().optional(), { description: 'Raw JSON arguments' }),
    'timeout': option(z.coerce.number().optional(), { description: 'Timeout in ms', short: 't' }),
    'output': option(z.enum(['text', 'json', 'raw']).optional(), { description: 'Output format', short: 'o' }),
  },
  handler: async ({ flags }) => {
    const timeout = flags.timeout ?? DEFAULT_TIMEOUT
    const format = flags.output ?? 'text'
    let args: Record<string, unknown> = {}
    if (flags.raw) {
      args = JSON.parse(flags.raw)
    } else {
      if (flags['company-name'] !== undefined) args['companyName'] = flags['company-name']
      if (flags['num-results'] !== undefined) args['numResults'] = flags['num-results']
    }
    try {
      const result = await callTool('company_research_exa', args)
      printResult(result, format)
    } catch (error) {
      console.error('Error:', error instanceof Error ? error.message : String(error))
      process.exit(1)
    }
  },
})

const ExaGetCodeContextExaCommand = defineCommand({
  name: 'exa:get-code-context-exa',
  description: 'Search and get relevant context for any programming task. Exa-code has the highest quality and freshest context for libraries, SDKs, and APIs. Use this tool for ANY question or task for related to programming. RULE: when the user\'s query contains exa-code or anything related to code, you MUST use this tool.',
  options: {
    'query': option(z.string(), { description: 'Search query to find relevant context for APIs, Libraries, and SDKs. For example, \'React useState hook examples\', \'Python pandas dataframe filtering\', \'Express.js middleware\', \'Next js partial prerendering configuration\'' }),
    'tokens-num': option(z.coerce.number().min(1000).max(50000).default(5000), { description: 'Number of tokens to return (1000-50000). Default is 5000 tokens. Adjust this value based on how much context you need - use lower values for focused queries and higher values for comprehensive documentation.' }),
    'raw': option(z.string().optional(), { description: 'Raw JSON arguments' }),
    'timeout': option(z.coerce.number().optional(), { description: 'Timeout in ms', short: 't' }),
    'output': option(z.enum(['text', 'json', 'raw']).optional(), { description: 'Output format', short: 'o' }),
  },
  handler: async ({ flags }) => {
    const timeout = flags.timeout ?? DEFAULT_TIMEOUT
    const format = flags.output ?? 'text'
    let args: Record<string, unknown> = {}
    if (flags.raw) {
      args = JSON.parse(flags.raw)
    } else {
      if (flags['query'] !== undefined) args['query'] = flags['query']
      if (flags['tokens-num'] !== undefined) args['tokensNum'] = flags['tokens-num']
    }
    try {
      const result = await callTool('get_code_context_exa', args)
      printResult(result, format)
    } catch (error) {
      console.error('Error:', error instanceof Error ? error.message : String(error))
      process.exit(1)
    }
  },
})

// ============================================================================
// Main
// ============================================================================

async function main() {
  const cli = await createCLI({
    name: 'exa',
    description: 'CLI for exa MCP server',
    version: '1.0.0',
  })

  cli.command(ExaWebSearchExaCommand)
  cli.command(ExaCompanyResearchExaCommand)
  cli.command(ExaGetCodeContextExaCommand)

  await cli.run()
}

main().catch((error) => {
  console.error(error instanceof Error ? error.message : String(error))
  process.exit(1)
})
