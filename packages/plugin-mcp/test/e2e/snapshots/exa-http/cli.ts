#!/usr/bin/env bun
/**
 * Generated CLI for exa MCP server
 * Generated by @bunli/plugin-mcp E2E tests
 */
import { createCLI, defineCommand, option } from '@bunli/core'
import { z } from 'zod'

// ============================================================================
// Configuration
// ============================================================================

const DEFAULT_TIMEOUT = 60000

// ============================================================================
// Helpers (stubbed for snapshot testing)
// ============================================================================

async function callTool(toolName: string, args: Record<string, unknown>): Promise<unknown> {
  // Stub implementation - in real usage this would call the MCP server
  throw new Error(`callTool not implemented: ${toolName}`)
}

function printResult(result: unknown, format: string): void {
  switch (format) {
    case 'json':
      console.log(JSON.stringify(result, null, 2))
      return
    case 'raw':
      console.log(JSON.stringify(result, null, 2))
      return
    default:
      console.log(result)
  }
}

// ============================================================================
// Commands
// ============================================================================

const ExaWebSearchExaCommand = defineCommand({
  name: 'exa:web-search-exa',
  description: 'Search the web for any topic and get clean, ready-to-use content.\n\nBest for: Finding current information, news, facts, or answering questions about any topic.\nReturns: Clean text content from top search results, ready for LLM use.',
  options: {
    'query': option(z.string(), { description: 'Websearch query' }),
    'num-results': option(z.coerce.number().optional(), { description: 'Number of search results to return (default: 8)' }),
    'livecrawl': option(z.enum(['fallback', 'preferred']).optional(), { description: 'Live crawl mode - \'fallback\': use live crawling as backup if cached content unavailable, \'preferred\': prioritize live crawling (default: \'fallback\')' }),
    'type': option(z.enum(['auto', 'fast', 'deep']).optional(), { description: 'Search type - \'auto\': balanced search (default), \'fast\': quick results, \'deep\': comprehensive search' }),
    'context-max-characters': option(z.coerce.number().optional(), { description: 'Maximum characters for context string optimized for LLMs (default: 10000)' }),
    'raw': option(z.string().optional(), { description: 'Raw JSON arguments' }),
    'timeout': option(z.coerce.number().optional(), { description: 'Timeout in ms', short: 't' }),
    'output': option(z.enum(['text', 'json', 'raw']).optional(), { description: 'Output format', short: 'o' }),
  },
  handler: async ({ flags }) => {
    const timeout = flags.timeout ?? DEFAULT_TIMEOUT
    const format = flags.output ?? 'text'
    let args: Record<string, unknown> = {}
    if (flags.raw) {
      args = JSON.parse(flags.raw)
    } else {
      if (flags['query'] !== undefined) args['query'] = flags['query']
      if (flags['num-results'] !== undefined) args['numResults'] = flags['num-results']
      if (flags['livecrawl'] !== undefined) args['livecrawl'] = flags['livecrawl']
      if (flags['type'] !== undefined) args['type'] = flags['type']
      if (flags['context-max-characters'] !== undefined) args['contextMaxCharacters'] = flags['context-max-characters']
    }
    try {
      const result = await callTool('web_search_exa', args)
      printResult(result, format)
    } catch (error) {
      console.error('Error:', error instanceof Error ? error.message : String(error))
      process.exit(1)
    }
  },
})

const ExaCompanyResearchExaCommand = defineCommand({
  name: 'exa:company-research-exa',
  description: 'Research any company to get business information, news, and insights.\n\nBest for: Learning about a company\'s products, services, recent news, or industry position.\nReturns: Company information from trusted business sources.',
  options: {
    'company-name': option(z.string(), { description: 'Name of the company to research' }),
    'num-results': option(z.coerce.number().optional(), { description: 'Number of search results to return (default: 5)' }),
    'raw': option(z.string().optional(), { description: 'Raw JSON arguments' }),
    'timeout': option(z.coerce.number().optional(), { description: 'Timeout in ms', short: 't' }),
    'output': option(z.enum(['text', 'json', 'raw']).optional(), { description: 'Output format', short: 'o' }),
  },
  handler: async ({ flags }) => {
    const timeout = flags.timeout ?? DEFAULT_TIMEOUT
    const format = flags.output ?? 'text'
    let args: Record<string, unknown> = {}
    if (flags.raw) {
      args = JSON.parse(flags.raw)
    } else {
      if (flags['company-name'] !== undefined) args['companyName'] = flags['company-name']
      if (flags['num-results'] !== undefined) args['numResults'] = flags['num-results']
    }
    try {
      const result = await callTool('company_research_exa', args)
      printResult(result, format)
    } catch (error) {
      console.error('Error:', error instanceof Error ? error.message : String(error))
      process.exit(1)
    }
  },
})

const ExaGetCodeContextExaCommand = defineCommand({
  name: 'exa:get-code-context-exa',
  description: 'Find code examples, documentation, and programming solutions. Searches GitHub, Stack Overflow, and official docs.\n\nBest for: Any programming question - API usage, library examples, code snippets, debugging help.\nReturns: Relevant code and documentation, formatted for easy reading.',
  options: {
    'query': option(z.string(), { description: 'Search query to find relevant context for APIs, Libraries, and SDKs. For example, \'React useState hook examples\', \'Python pandas dataframe filtering\', \'Express.js middleware\', \'Next js partial prerendering configuration\'' }),
    'tokens-num': option(z.coerce.number().min(1000).max(50000).default(5000), { description: 'Number of tokens to return (1000-50000). Default is 5000 tokens. Adjust this value based on how much context you need - use lower values for focused queries and higher values for comprehensive documentation.' }),
    'raw': option(z.string().optional(), { description: 'Raw JSON arguments' }),
    'timeout': option(z.coerce.number().optional(), { description: 'Timeout in ms', short: 't' }),
    'output': option(z.enum(['text', 'json', 'raw']).optional(), { description: 'Output format', short: 'o' }),
  },
  handler: async ({ flags }) => {
    const timeout = flags.timeout ?? DEFAULT_TIMEOUT
    const format = flags.output ?? 'text'
    let args: Record<string, unknown> = {}
    if (flags.raw) {
      args = JSON.parse(flags.raw)
    } else {
      if (flags['query'] !== undefined) args['query'] = flags['query']
      if (flags['tokens-num'] !== undefined) args['tokensNum'] = flags['tokens-num']
    }
    try {
      const result = await callTool('get_code_context_exa', args)
      printResult(result, format)
    } catch (error) {
      console.error('Error:', error instanceof Error ? error.message : String(error))
      process.exit(1)
    }
  },
})

// ============================================================================
// Main
// ============================================================================

async function main() {
  const cli = await createCLI({
    name: 'exa',
    description: 'CLI for exa MCP server',
    version: '1.0.0',
  })

  cli.command(ExaWebSearchExaCommand)
  cli.command(ExaCompanyResearchExaCommand)
  cli.command(ExaGetCodeContextExaCommand)

  await cli.run()
}

main().catch((error) => {
  console.error(error instanceof Error ? error.message : String(error))
  process.exit(1)
})
