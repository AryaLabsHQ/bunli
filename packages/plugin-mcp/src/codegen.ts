/**
 * Type generation for MCP commands
 *
 * Generates TypeScript files with Zod schemas and module augmentation
 * for RegisteredCommands. Similar to Prisma's client generation pattern.
 */

import { mkdir, writeFile } from 'fs/promises'
import { join } from 'path'
import type { GenerateTypesOptions, MCPToolGroup, MCPTool, JSONSchema7 } from './types.js'
import { extractCommandMetadata, type MCPCommandMetadata } from './converter.js'
import { toPascalCase, escapeString } from './utils.js'

/**
 * Generate TypeScript types for MCP commands
 *
 * Creates files like `.bunli/mcp-linear.gen.ts` with:
 * - Zod schemas for each command's options
 * - TypeScript types inferred from schemas
 * - Module augmentation for RegisteredCommands
 *
 * @example
 * ```typescript
 * await generateMCPTypes({
 *   tools: [
 *     { namespace: 'linear', tools: linearTools }
 *   ],
 *   outputDir: '.bunli'
 * })
 * ```
 */
export async function generateMCPTypes(options: GenerateTypesOptions): Promise<void> {
  const { tools, outputDir } = options

  // Ensure output directory exists
  await mkdir(outputDir, { recursive: true })

  // Generate a file for each namespace
  for (const { namespace, tools: toolList } of tools) {
    if (!toolList || toolList.length === 0) continue

    const content = generateNamespaceTypes(namespace, toolList)
    const fileName = `mcp-${namespace}.gen.ts`
    const filePath = join(outputDir, fileName)

    await writeFile(filePath, content, 'utf-8')
  }

  // Generate index file that re-exports all
  const indexContent = generateIndexFile(tools)
  await writeFile(join(outputDir, 'mcp-index.gen.ts'), indexContent, 'utf-8')
}

/**
 * Generate types for a single namespace
 */
function generateNamespaceTypes(namespace: string, tools: MCPTool[]): string {
  const lines: string[] = []

  // Header
  lines.push(`// This file was automatically generated by @bunli/plugin-mcp`)
  lines.push(`// DO NOT EDIT - changes will be overwritten`)
  lines.push(``)
  lines.push(`import type { Command, Options, CLIOption } from '@bunli/core'`)
  lines.push(`import { option } from '@bunli/core'`)
  lines.push(`import { z } from 'zod'`)
  lines.push(``)

  // Extract metadata for all tools
  const metadata = tools.map(tool => extractCommandMetadata(tool, namespace))

  // Generate Zod schemas and types for each command
  for (const cmd of metadata) {
    lines.push(generateCommandSchema(cmd))
    lines.push(``)
  }

  // Generate module augmentation
  lines.push(generateModuleAugmentation(namespace, metadata))

  return lines.join('\n')
}

/**
 * Generate Zod schema and types for a single command
 */
function generateCommandSchema(cmd: MCPCommandMetadata): string {
  const lines: string[] = []
  const baseName = toPascalCase(cmd.name)

  // Generate options object
  lines.push(`// ${cmd.description || cmd.toolName}`)
  lines.push(`export const ${baseName}Options = {`)

  for (const [flagName, opt] of Object.entries(cmd.options)) {
    const zodSchema = generateZodSchemaString(opt)
    const metadata: string[] = []

    if (opt.description) {
      metadata.push(`description: '${escapeString(opt.description)}'`)
    }
    if (opt.short) {
      metadata.push(`short: '${opt.short}'`)
    }

    const metadataStr = metadata.length > 0 ? `, { ${metadata.join(', ')} }` : ''
    lines.push(`  '${flagName}': option(${zodSchema}${metadataStr}),`)
  }

  lines.push(`} as const`)
  lines.push(``)

  // Generate flags type
  lines.push(`export type ${baseName}Flags = {`)

  for (const [flagName, opt] of Object.entries(cmd.options)) {
    const tsType = jsonSchemaTypeToTS(opt.type, opt.enumValues)
    const optional = !opt.required ? '?' : ''
    lines.push(`  '${flagName}'${optional}: ${tsType}`)
  }

  lines.push(`}`)

  return lines.join('\n')
}

/**
 * Generate Zod schema string from option metadata
 */
function generateZodSchemaString(opt: MCPCommandMetadata['options'][string]): string {
  let schema: string

  // Handle enum types
  if (opt.enumValues && opt.enumValues.length > 0) {
    if (opt.enumValues.every((v): v is string => typeof v === 'string')) {
      const values = opt.enumValues.map(v => `'${escapeString(v as string)}'`).join(', ')
      schema = `z.enum([${values}])`
    } else {
      const literals = opt.enumValues.map(v =>
        typeof v === 'string' ? `z.literal('${escapeString(v)}')` : `z.literal(${v})`
      ).join(', ')
      schema = `z.union([${literals}])`
    }
  } else {
    // Handle base types
    switch (opt.type) {
      case 'string':
        schema = 'z.string()'
        break
      case 'number':
        schema = 'z.coerce.number()'
        break
      case 'integer':
        schema = 'z.coerce.number().int()'
        break
      case 'boolean':
        schema = 'z.boolean()'
        break
      case 'array':
        schema = 'z.array(z.unknown())'
        break
      case 'object':
        schema = 'z.record(z.unknown())'
        break
      default:
        schema = 'z.unknown()'
    }
  }

  // Add constraints
  if (opt.minimum !== undefined) {
    schema += `.min(${opt.minimum})`
  }
  if (opt.maximum !== undefined) {
    schema += `.max(${opt.maximum})`
  }

  // Add default
  if (opt.hasDefault && opt.default !== undefined) {
    const defaultVal = typeof opt.default === 'string'
      ? `'${escapeString(opt.default)}'`
      : JSON.stringify(opt.default)
    schema += `.default(${defaultVal})`
  }

  // Make optional if not required
  if (!opt.required && !opt.hasDefault) {
    schema += '.optional()'
  }

  return schema
}

/**
 * Convert JSON Schema type to TypeScript type
 */
function jsonSchemaTypeToTS(
  type: string,
  enumValues?: Array<string | number>
): string {
  // Handle enum
  if (enumValues && enumValues.length > 0) {
    return enumValues
      .map(v => typeof v === 'string' ? `'${escapeString(v)}'` : String(v))
      .join(' | ')
  }

  switch (type) {
    case 'string':
      return 'string'
    case 'number':
    case 'integer':
      return 'number'
    case 'boolean':
      return 'boolean'
    case 'array':
      return 'unknown[]'
    case 'object':
      return 'Record<string, unknown>'
    case 'null':
      return 'null'
    default:
      return 'unknown'
  }
}

/**
 * Generate module augmentation for RegisteredCommands
 */
function generateModuleAugmentation(
  namespace: string,
  metadata: MCPCommandMetadata[]
): string {
  const lines: string[] = []

  lines.push(`// Module augmentation for type-safe execute()`)
  lines.push(`declare module '@bunli/core' {`)
  lines.push(`  interface RegisteredCommands {`)

  for (const cmd of metadata) {
    const baseName = toPascalCase(cmd.name)
    lines.push(`    '${cmd.name}': Command<typeof ${baseName}Options>`)
  }

  lines.push(`  }`)
  lines.push(`}`)

  return lines.join('\n')
}

/**
 * Generate index file that re-exports all namespaces
 */
function generateIndexFile(toolGroups: MCPToolGroup[]): string {
  const lines: string[] = []

  lines.push(`// This file was automatically generated by @bunli/plugin-mcp`)
  lines.push(`// DO NOT EDIT - changes will be overwritten`)
  lines.push(``)

  for (const { namespace } of toolGroups) {
    if (!namespace) continue
    lines.push(`export * from './mcp-${namespace}.gen.js'`)
  }

  return lines.join('\n')
}
