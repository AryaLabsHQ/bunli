import type { CommandMetadata } from './types.js'
import { createGeneratedHelpers, registerGeneratedStore } from '@bunli/core'

// Minimal command type reference to avoid direct import of core types during generation
export interface GeneratedCommand {
  name: string
  description: string
  options?: Record<string, unknown>
  commands?: GeneratedCommand[]
  alias?: string | string[]
}

export function buildTypes(commands: CommandMetadata[]): string {
  // Ensure sort-stable output
  commands = [...commands].sort((a, b) => a.name.localeCompare(b.name))
  // Create unique variable names to avoid collisions
  const varNames = new Map<string, string>()
  const usedNames = new Set<string>()
  
  for (const cmd of commands) {
    let baseName = getCommandVarName(cmd.name)
    let uniqueName = baseName
    let counter = 1
    
    while (usedNames.has(uniqueName)) {
      uniqueName = `${baseName}${counter}`
      counter++
    }
    
    usedNames.add(uniqueName)
    varNames.set(cmd.name, uniqueName)
  }

  const imports = commands.map(cmd => {
    const varName = varNames.get(cmd.name)!
    return `import ${varName} from '${cmd.importPath}'`
  }).join('\n')

  const commandEntries = commands.map(cmd => {
    const varName = varNames.get(cmd.name)!
    const safeName = escape(cmd.name)
    return `  '${safeName}': ${varName}`
  }).join(',\n')

  const metadataEntries = commands.map(cmd => {
    const safeName = cmd.name.replace(/'/g, "\\'")
    return `  '${safeName}': ${buildMetadataObject(cmd, '    ')}`
  }).join(',\n')

  const nameLiterals = commands.map(cmd => `'${escape(cmd.name)}'`).join(', ')

  return `// This file was automatically generated by Bunli.
// You should NOT make any changes in this file as it will be overwritten.

import type { Command, CLI, GeneratedOptionMeta, RegisteredCommands, CommandOptions, GeneratedCommandMeta } from '@bunli/core'
import { createGeneratedHelpers, registerGeneratedStore } from '@bunli/core'

${imports}

// Narrow list of command names to avoid typeof-cycles in types
const names = [${nameLiterals}] as const
type GeneratedNames = typeof names[number]

const modules: Record<GeneratedNames, Command<any>> = {
${commandEntries}
} as const

const metadata: Record<GeneratedNames, GeneratedCommandMeta> = {
${metadataEntries}
} as const

export const generated = registerGeneratedStore(createGeneratedHelpers(modules, metadata))

export const commands = generated.commands
export const commandMeta = generated.metadata

export interface GeneratedCLI {
  register(cli?: CLI<any>): GeneratedCLI
  list(): Array<{
    name: GeneratedNames
    command: (typeof modules)[GeneratedNames]
    metadata: (typeof metadata)[GeneratedNames]
  }>
  get<Name extends GeneratedNames>(name: Name): (typeof modules)[Name]
  getMetadata<Name extends GeneratedNames>(name: Name): (typeof metadata)[Name]
  getFlags<Name extends keyof RegisteredCommands & string>(name: Name): CommandOptions<Name>
  getFlagsMeta<Name extends GeneratedNames>(name: Name): Record<string, GeneratedOptionMeta>
  withCLI(cli: CLI<any>): { execute(name: string, options: unknown): Promise<void> }
}

export const cli: GeneratedCLI = {
  register: (cliInstance?: CLI<any>) => { generated.register(cliInstance); return cli },
  list: () => generated.list(),
  get: <Name extends GeneratedNames>(name: Name) => generated.get(name),
  getMetadata: <Name extends GeneratedNames>(name: Name) => generated.getMetadata(name),
  getFlags: <Name extends keyof RegisteredCommands & string>(name: Name) => generated.getFlags(name) as CommandOptions<Name>,
  getFlagsMeta: <Name extends GeneratedNames>(name: Name) => generated.getFlagsMeta(name),
  withCLI: (cliInstance) => generated.withCLI(cliInstance)
}

// Enhanced helper functions
export const listCommands = () => generated.list().map(c => c.name)
export const getCommandApi = <Name extends GeneratedNames>(name: Name) => generated.getMetadata(name)
export const getTypedFlags = <Name extends GeneratedNames>(name: Name) => generated.getFlags(name) as CommandOptions<Name>
export const validateCommand = <Name extends GeneratedNames>(name: Name, flags: Record<string, unknown>) => generated.validateCommand(name, flags)
export const findCommandByName = <Name extends GeneratedNames>(name: Name) => generated.findByName(name)
export const findCommandsByDescription = (searchTerm: string) => generated.findByDescription(searchTerm)
export const getCommandNames = () => generated.getCommandNames()

// Auto-register on import for zero-config usage
export default cli

// Ensure module augmentation happens on import
declare module '@bunli/core' {
  // Precise key mapping without typeof cycles
  interface RegisteredCommands extends Record<GeneratedNames, Command<any>> {}
}
`
}

function getCommandVarName(commandName: string): string {
  return commandName
    .split(/[^a-zA-Z0-9]/)
    .filter(Boolean)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('') || 'Command'
}

function buildMetadataObject(command: CommandMetadata, indent: string): string {
  const lines: string[] = []
  lines.push('{')
  lines.push(`${indent}  name: '${escape(command.name)}',`)
  lines.push(`${indent}  description: '${escape(command.description || '')}',`)
  if (command.alias) {
    if (Array.isArray(command.alias)) {
      lines.push(`${indent}  alias: ${JSON.stringify(command.alias)},`)
    } else {
      lines.push(`${indent}  alias: '${escape(command.alias)}',`)
    }
  }
  if (command.options && Object.keys(command.options).length > 0) {
    const optionLines = Object.entries(command.options).map(([name, option]) => {
      const optionMeta = [
        `type: '${option.type}'`,
        `required: ${option.required}`,
        `hasDefault: ${option.hasDefault}`,
        option.hasDefault ? `default: ${JSON.stringify(option.default)}` : undefined,
        option.description ? `description: '${escape(option.description)}'` : undefined,
        option.short ? `short: '${escape(option.short)}'` : undefined,
        // Enhanced completion metadata
        option.enumValues ? `enumValues: ${JSON.stringify(option.enumValues)}` : undefined,
        option.literalValue !== undefined ? `literalValue: ${JSON.stringify(option.literalValue)}` : undefined,
        option.min !== undefined ? `min: ${option.min}` : undefined,
        option.max !== undefined ? `max: ${option.max}` : undefined,
        option.minLength !== undefined ? `minLength: ${option.minLength}` : undefined,
        option.maxLength !== undefined ? `maxLength: ${option.maxLength}` : undefined,
        option.pattern ? `pattern: '${escape(option.pattern)}'` : undefined,
        option.isArray ? `isArray: true` : undefined,
        option.isTransform ? `isTransform: true` : undefined,
        option.isRefine ? `isRefine: true` : undefined,
        option.fileType ? `fileType: '${option.fileType}'` : undefined,
        // Schema information
        option.schema ? `schema: ${JSON.stringify(option.schema)}` : undefined,
        option.validator ? `validator: '${escape(option.validator)}'` : undefined
      ].filter(Boolean).join(', ')
      return `${indent}    '${name}': { ${optionMeta} }`
    })
    lines.push(`${indent}  options: {`)
    lines.push(optionLines.join(',\n'))
    lines.push(`${indent}  },`)
  }
  if (command.commands && command.commands.length > 0) {
    lines.push(`${indent}  commands: [`)
    lines.push(command.commands.map(sub => `${indent}    ${buildMetadataObject(sub, indent + '    ')}`).join(',\n'))
    lines.push(`${indent}  ],`)
  }
  lines.push(`${indent}  path: '${escape(command.exportPath)}'`)
  lines.push(`${indent}}`)
  return lines.join('\n')
}

function escape(value: string | undefined): string {
  return (value ?? '').replace(/'/g, "\\'")
}
