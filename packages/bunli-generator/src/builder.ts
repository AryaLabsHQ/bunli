import type { CommandMetadata, CommandRegistry } from './types.js'

export function buildTypes(commands: CommandMetadata[]): string {
  const registry = buildCommandRegistry(commands)
  const registryType = buildRegistryType(registry)
  const moduleAugmentation = buildModuleAugmentation()
  const helperFunctions = buildHelperFunctions()

  return `// This file was automatically generated by Bunli.
// You should NOT make any changes in this file as it will be overwritten.

${registryType}

${moduleAugmentation}

${helperFunctions}

// Command registry for runtime access
export const commandRegistry: CommandRegistry = ${JSON.stringify(registry, null, 2)} as const
`
}

function buildCommandRegistry(commands: CommandMetadata[]): CommandRegistry {
  const registry: CommandRegistry = {}

  for (const command of commands) {
    registry[command.name] = {
      name: command.name,
      description: command.description,
      alias: command.alias,
      options: command.options,
      filePath: command.filePath,
      exportPath: command.exportPath
    }
  }

  return registry
}

function buildRegistryType(registry: CommandRegistry): string {
  const entries = Object.entries(registry)
    .map(([name, command]) => {
      const optionsType = command.options 
        ? buildOptionsType(command.options)
        : '{}'
      
      return `  '${name}': {
    name: '${command.name}'
    description: '${command.description}'
    ${command.alias ? `alias: ${JSON.stringify(command.alias)}` : ''}
    ${command.options ? `options: ${optionsType}` : ''}
    filePath: '${command.filePath}'
    exportPath: '${command.exportPath}'
  }`
    })
    .join('\n')

  return `export interface CommandRegistry {
${entries}
}`
}

function buildOptionsType(options: Record<string, any>): string {
  const optionEntries = Object.entries(options)
    .map(([name, option]) => {
      return `    ${name}: {
      type: '${option.type}'
      required: ${option.required}
      ${option.default !== undefined ? `default: ${JSON.stringify(option.default)}` : ''}
      ${option.description ? `description: '${option.description}'` : ''}
      ${option.short ? `short: '${option.short}'` : ''}
    }`
    })
    .join('\n')

  return `{
${optionEntries}
  }`
}

function buildModuleAugmentation(): string {
  return `declare module '@bunli/core' {
  interface GeneratedCommands extends CommandRegistry {}
}`
}

function buildHelperFunctions(): string {
  return `/**
 * Get command metadata by name
 */
export function getCommandApi<T extends keyof CommandRegistry>(
  name: T
): CommandRegistry[T] {
  return commandRegistry[name]
}

/**
 * Get all command names
 */
export function getCommandNames(): (keyof CommandRegistry)[] {
  return Object.keys(commandRegistry) as (keyof CommandRegistry)[]
}

/**
 * Check if a command exists
 */
export function hasCommand(name: string): name is keyof CommandRegistry {
  return name in commandRegistry
}

/**
 * Get command by alias
 */
export function getCommandByAlias(alias: string): keyof CommandRegistry | undefined {
  for (const [name, command] of Object.entries(commandRegistry)) {
    if (command.alias) {
      if (typeof command.alias === 'string' && command.alias === alias) {
        return name as keyof CommandRegistry
      }
      if (Array.isArray(command.alias) && command.alias.includes(alias)) {
        return name as keyof CommandRegistry
      }
    }
  }
  return undefined
}

/**
 * List all commands with their metadata
 */
export function listCommands(): Array<{
  name: keyof CommandRegistry
  description: string
  alias?: string | string[]
  options?: Record<string, any>
}> {
  return Object.entries(commandRegistry).map(([name, command]) => ({
    name: name as keyof CommandRegistry,
    description: command.description,
    alias: command.alias,
    options: command.options
  }))
}`
}
