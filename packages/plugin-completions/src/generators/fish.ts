import type { CommandMetadata, OptionMetadata } from '@bunli/generator'

export function generateFish(commands: CommandMetadata[], cliName: string): string {
  let script = `# Fish completion script for ${cliName}\n`
  script += `# Generated by @bunli/plugin-completions\n\n`

  // Helper function to check if no subcommand is used
  script += `function __fish_${sanitizeName(cliName)}_no_subcommand\n`
  script += `  set -l cmd (commandline -opc)\n`
  script += `  if [ (count $cmd) -eq 1 ]\n`
  script += `    return 0\n`
  script += `  end\n`
  script += `  return 1\n`
  script += `end\n\n`

  // Command completions
  script += `# Command completions\n`
  for (const cmd of commands) {
    const desc = escapeFish(cmd.description)
    script += `complete -c ${cliName} -f -n '__fish_${sanitizeName(cliName)}_no_subcommand' -a '${cmd.name}' -d '${desc}'\n`
  }

  script += `\n`

  // Generate option completions for each command
  for (const cmd of commands) {
    script += generateFishCommandCompletion(cmd, cliName)
  }

  return script
}

function generateFishCommandCompletion(cmd: CommandMetadata, cliName: string): string {
  let script = `# Completions for ${cmd.name}\n`

  if (cmd.options && Object.keys(cmd.options).length > 0) {
    for (const [name, opt] of Object.entries(cmd.options)) {
      const condition = `__fish_seen_subcommand_from ${cmd.name}`
      const desc = opt.description ? escapeFish(opt.description) : ''

      let line = `complete -c ${cliName} -n '${condition}'`
      line += ` -l ${name}`

      if (opt.short) {
        line += ` -s ${opt.short}`
      }

      if (desc) {
        line += ` -d '${desc}'`
      }

      // Mark as requiring an argument if it's not a boolean
      const isBooleanFlag = opt.type.includes('boolean') || opt.type.includes('bool')
      if (!isBooleanFlag && opt.required) {
        line += ` -r`
      }

      // Add enum value completions
      if (opt.enumValues && opt.enumValues.length > 0) {
        const values = opt.enumValues.map(v => escapeFish(String(v))).join(' ')
        line += ` -a '${values}'`
      }

      script += line + '\n'
    }
  }

  // Handle nested commands
  if (cmd.commands && cmd.commands.length > 0) {
    script += `\n# Subcommands for ${cmd.name}\n`
    for (const subcmd of cmd.commands) {
      const desc = escapeFish(subcmd.description)
      script += `complete -c ${cliName} -n '__fish_seen_subcommand_from ${cmd.name}' -a '${subcmd.name}' -d '${desc}'\n`
    }
  }

  script += `\n`

  return script
}

function escapeFish(str: string): string {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/'/g, "\\'")
    .replace(/"/g, '\\"')
}

function sanitizeName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_]/g, '_')
}
