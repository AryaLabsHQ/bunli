import type { CommandMetadata, OptionMetadata } from '@bunli/generator'

export function generateZsh(commands: CommandMetadata[], cliName: string): string {
  let script = `#compdef ${cliName}\n`
  script += `# Zsh completion script for ${cliName}\n`
  script += `# Generated by @bunli/plugin-completions\n\n`

  script += `_${sanitizeName(cliName)}() {\n`
  script += `  local line state\n\n`

  script += `  _arguments -C \\\n`
  script += `    "1: :->cmds" \\\n`
  script += `    "*::arg:->args"\n\n`

  script += `  case $state in\n`
  script += `    cmds)\n`

  // Generate command list with descriptions
  script += `      _values "commands" \\\n`
  for (let i = 0; i < commands.length; i++) {
    const cmd = commands[i]
    if (!cmd) continue
    const desc = escapeZsh(cmd.description)
    const trailing = i < commands.length - 1 ? ' \\' : ''
    script += `        "${cmd.name}[${desc}]"${trailing}\n`
  }

  script += `      ;;\n\n`

  script += `    args)\n`
  script += `      case $line[1] in\n`

  // Generate completions for each command
  for (const cmd of commands) {
    script += generateZshCommandCompletion(cmd, '        ')
  }

  script += `      esac\n`
  script += `      ;;\n`
  script += `  esac\n`
  script += `}\n\n`

  script += `_${sanitizeName(cliName)} "$@"\n`

  return script
}

function generateZshCommandCompletion(cmd: CommandMetadata, indent: string): string {
  let script = `${indent}${cmd.name})\n`

  if (cmd.options && Object.keys(cmd.options).length > 0) {
    script += `${indent}  _arguments \\\n`

    const entries = Object.entries(cmd.options)
    for (let i = 0; i < entries.length; i++) {
      const entry = entries[i]
      if (!entry) continue
      const [name, opt] = entry
      const isLast = i === entries.length - 1

      const desc = opt.description ? escapeZsh(opt.description) : name
      const long = `--${name}`
      const short = opt.short ? `-${opt.short}` : null

      let line = `${indent}    `

      if (short) {
        // Both short and long forms
        line += `"(${short} ${long})"{${short},${long}}`
      } else {
        // Long form only
        line += `"${long}`
      }

      // Add description
      line += `[${desc}]`

      // Add value completion if enum values exist
      if (opt.enumValues && opt.enumValues.length > 0) {
        const values = opt.enumValues.map((v: string | number) => `${v}`).join(' ')
        line += `:(${values})`
      } else if (!opt.required && opt.hasDefault) {
        // Optional with default
        line += `::`
      } else if (opt.required) {
        // Required argument
        line += `:`
      }

      line += `"`

      if (!isLast) {
        line += ' \\'
      }

      script += line + '\n'
    }
  }

  // Handle nested commands
  if (cmd.commands && cmd.commands.length > 0) {
    script += `${indent}  # Subcommands available but not implemented in completion\n`
  }

  script += `${indent}  ;;\n\n`

  return script
}

function escapeZsh(str: string): string {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/'/g, "\\'")
    .replace(/"/g, '\\"')
    .replace(/\[/g, '\\[')
    .replace(/\]/g, '\\]')
}

function sanitizeName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_]/g, '_')
}
