import type { CommandMetadata, OptionMetadata } from '@bunli/generator'

export function generateBash(commands: CommandMetadata[], cliName: string): string {
  const commandNames = commands.map(cmd => cmd.name).join(' ')

  let script = `# Bash completion script for ${cliName}\n`
  script += `# Generated by @bunli/plugin-completions\n\n`

  script += `_${sanitizeName(cliName)}_completions() {\n`
  script += `  local cur prev words cword\n`
  script += `  _init_completion || return\n\n`

  script += `  local commands="${commandNames}"\n\n`

  // Main command completion
  script += `  # Complete main commands\n`
  script += `  if [[ \${cword} -eq 1 ]]; then\n`
  script += `    COMPREPLY=($(compgen -W "$commands --help --version" -- "$cur"))\n`
  script += `    return\n`
  script += `  fi\n\n`

  // Command-specific completion
  script += `  # Command-specific completions\n`
  script += `  local command=\${words[1]}\n\n`

  for (const cmd of commands) {
    script += generateBashCommandCompletion(cmd, '  ')
  }

  script += `}\n\n`

  script += `complete -F _${sanitizeName(cliName)}_completions ${cliName}\n`

  return script
}

function generateBashCommandCompletion(cmd: CommandMetadata, indent: string): string {
  let script = `${indent}if [[ "$command" == "${cmd.name}" ]]; then\n`

  if (cmd.options && Object.keys(cmd.options).length > 0) {
    // Generate flag list
    const flags: string[] = []
    for (const [name, opt] of Object.entries(cmd.options)) {
      flags.push(`--${name}`)
      if (opt.short) {
        flags.push(`-${opt.short}`)
      }
    }

    const flagsList = flags.join(' ')
    script += `${indent}  local flags="${flagsList}"\n\n`

    // Handle flag value completions
    let hasEnumCompletions = false
    for (const [name, opt] of Object.entries(cmd.options)) {
      if (opt.enumValues && opt.enumValues.length > 0) {
        hasEnumCompletions = true
        const values = opt.enumValues.join(' ')
        script += `${indent}  # Completions for --${name}\n`
        script += `${indent}  if [[ "$prev" == "--${name}"${opt.short ? ` || "$prev" == "-${opt.short}"` : ''} ]]; then\n`
        script += `${indent}    COMPREPLY=($(compgen -W "${values}" -- "$cur"))\n`
        script += `${indent}    return\n`
        script += `${indent}  fi\n\n`
      }
    }

    // General flag completion
    script += `${indent}  # Complete flags\n`
    script += `${indent}  if [[ "$cur" == -* ]]; then\n`
    script += `${indent}    COMPREPLY=($(compgen -W "$flags" -- "$cur"))\n`
    script += `${indent}    return\n`
    script += `${indent}  fi\n`
  }

  // Handle nested commands
  if (cmd.commands && cmd.commands.length > 0) {
    const subcommands = cmd.commands.map(c => c.name).join(' ')
    script += `${indent}  # Subcommands\n`
    script += `${indent}  if [[ \${cword} -eq 2 ]]; then\n`
    script += `${indent}    COMPREPLY=($(compgen -W "${subcommands}" -- "$cur"))\n`
    script += `${indent}    return\n`
    script += `${indent}  fi\n`
  }

  script += `${indent}fi\n\n`

  return script
}

function sanitizeName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_]/g, '_')
}
